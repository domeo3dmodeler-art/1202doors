# Загрузка фото товаров: анализ и предложение по исправлению

> **Вернуться к предложению:** варианты A (Nginx static) → B (кеш в API) → C (лимиты Nginx) → D (меньше запросов/превью) → E (CDN). Рекомендуемый порядок: сначала A, при необходимости B и C. Подробности — в разделах 3–4 ниже.
>
> **Внедрено:** A, B, C. Конфиг Nginx: `scripts/output/domeo-nginx.conf` (location /uploads/ с try_files + @backend_uploads; uploads_limit 100r/s, burst 200; таймауты для uploads). Кеш: `app/api/uploads/[...path]/route.ts` (LRU, макс. 500 записей).
>
> **Фото ручек на ВМ:** API hardware и image-src отдают пути **/uploads/...** (не /api/uploads/), чтобы запросы шли в Nginx → раздача с диска (A); при отсутствии файла Nginx проксирует в Node (@backend_uploads) для fallback по имени. Так снимается 502 от перегрузки Node при массовой загрузке ручек.

## 1. Как устроена система загрузки фото (полная цепочка)

### 1.1 Источники путей к фото

| Тип фото | Источник данных | Где формируется путь |
|----------|-----------------|----------------------|
| **Двери (модели, покрытия, цвета)** | API `GET /api/catalog/doors/complete-data` | complete-data: PropertyPhoto (БД) + `normalizePhotoPath()` + `resolveDoorPhotoToExistingFile()` → поля `photo`, `photo_path` в формате `/uploads/...` |
| **Ручки, наличники, ограничители** | API `GET /api/catalog/hardware` | hardware/route.ts: пути нормализуются в `/api/uploads/...` для локальных файлов |
| **Прочие (products, gallery)** | Разные API / БД | Пути в виде `/uploads/...` или `/api/uploads/...` |

- **complete-data** возвращает десятки моделей (порядка 100+), у каждой: обложка `photo` и у каждого цвета/покрытия — `photo_path`. Итого на одну загрузку страницы конфигуратора приходит **много URL фото** (список моделей + при выборе модели — цвета/покрытия).
- **hardware** возвращает ручки/наличники/ограничители с полями `photo_path` (часто `/api/uploads/final-filled/04_Ручки_Завертки/...`).

### 1.2 Как браузер запрашивает фото

- В UI везде используется **`getImageSrc(path)`** / **`getImageSrcWithPlaceholder(path, placeholder)`** из `lib/configurator/image-src.ts`.
- Для дверей и большинства локальных фото путь из API остаётся **`/uploads/...`** (без смены на `/api/uploads/` в image-src).
- В **next.config.mjs** задан rewrite:
  ```js
  { source: '/uploads/:path*', destination: '/api/uploads/:path*' }
  ```
- Итого: браузер делает **GET /uploads/final-filled/doors/Файл.png** → Next.js перенаправляет запрос на **GET /api/uploads/final-filled/doors/Файл.png** → обрабатывает **`app/api/uploads/[...path]/route.ts`**.

То есть **никакой статической раздачи** для `/uploads/` нет: каждый запрос к картинке обрабатывается Node-обработчиком.

### 1.3 Обработчик GET /api/uploads/[...path]

- Файл: `app/api/uploads/[...path]/route.ts`.
- Для каждого запроса:
  - Декодирование сегментов URL (кириллица, %-кодирование), проверка path traversal.
  - Поиск файла: сначала **точный путь** в `public/uploads/`, при отсутствии — **fallback**:
    - ручки: поиск по коду (`handle_XXX_main.png`), затем `readdir` по папке ручек и сопоставление по нормализованному имени;
    - двери: **findDoorPhotoFile** — перебор расширений, префиксов (Дверь_, Дверное_полотно_), при необходимости **readdirSync** по всей папке `final-filled/doors` и сопоставление по префиксу/суффиксу.
  - **readFile(servePath)** и ответ с телом файла.
- Заголовки ответа: `Cache-Control: public, max-age=86400` (сутки).
- **Кеша в памяти в обработчике нет** — повторный запрос того же URL снова читает файл с диска (и при fallback снова может вызывать readdir).

### 1.4 Nginx перед приложением

- В `scripts/output/domeo-nginx.conf`:
  - **location /uploads/** и **location /api/uploads/** проксируют на один и тот же бэкенд (Next), без `limit_conn`, с **limit_req zone=uploads_limit burst=100 nodelay** (rate=50r/s).
  - Остальные запросы (в т.ч. HTML, API complete-data, hardware) идут в **location /** с **limit_conn conn_limit 25** и своими limit_req.

Итого: все запросы к картинкам идут в Node; Nginx только проксирует и ограничивает частоту.

### 1.5 Фронт: отображение и lazy loading

- В `app/doors/page.tsx` для миниатюр моделей, цветов, покрытий, ручек, наличников, ограничителей используются обычные **`<img loading="lazy" src={getImageSrc(...)} />`** (или с плейсхолдером).
- **loading="lazy"** уже стоит — браузер сам подгружает изображения при приближении к viewport, но как только элементы попадают в зону видимости (или близко), **одновременно** может стартовать много запросов к одному origin.

---

## 2. Почему загрузка медленная и не все фото появляются

### 2.1 Медленно

1. **Каждое фото = отдельный HTTP-запрос к Node**  
   Нет статической раздачи по `/uploads/`: все запросы обрабатываются одним приложением. Десятки картинок на странице = десятки последовательных/конкурентных запросов к одному процессу.

2. **На каждый запрос — чтение с диска**  
   В обработчике нет in-memory кеша: для одного и того же URL при повторном запросе снова выполняется `readFile` (и при 404 по точному пути — снова fallback с readdir). На ВМ диск и один процесс Node создают узкое место.

3. **Тяжёлый fallback при «нет точного файла»**  
   Для ручек — асинхронный `readdir` и перебор имён; для дверей — **readdirSync** по всей папке и сопоставление по префиксу/суффиксу. Если в БД много путей с опечатками или отличиями в именах файлов, часть запросов уходит в fallback и становится заметно медленнее.

4. **Ограничение параллелизма в браузере**  
   У одного origin обычно лимит одновременных соединений (часто 6 по HTTP/1.1). Поэтому даже при 50 URL картинки грузятся «волнами» по 6; каждая волна ждёт ответа Node. Если Node отвечает медленно из-за диска и fallback, общее время растёт.

5. **Один процесс Node**  
   Все readFile и fallback выполняются в одном потоке. При большом числе одновременных запросов очередь растёт, часть запросов долго ждёт в event loop.

### 2.2 Не все фото загружаются

1. **Лимиты Nginx**  
   limit_req для `/uploads/`: 50 r/s, burst 100. При массовой подгрузке (например, после скролла сразу много картинок) часть запросов может получать **503** (rate limit). Браузер покажет сломанную картинку или onError → плейсхолдер.

2. **Таймауты**  
   В Nginx для location `/` заданы proxy_read_timeout 60s; для `/uploads/` отдельный timeout не указан (наследуется). Если Node надолго зависает на readdir/fallback или под нагрузкой, запрос может обрываться по таймауту — картинка не догружается.

3. **404 из-за несовпадения путей**  
   В БД/PropertyPhoto путь может не совпадать с именем файла на диске (кириллица, скобки RAL/NCS, пробелы, другая нормализация). Тогда точный путь не находится, fallback не всегда находит аналог — API возвращает 404, на фронте срабатывает onError и показывается плейсхолдер.

4. **Перегрузка Node**  
   При большом числе одновременных запросов возможны задержки, таймауты или ошибки — часть картинок так и не успевает загрузиться.

---

## 3. Предложение по исправлению (без изменения кода — только план)

Цель: **быстрое отображение и загрузка всех фото** за счёт уменьшения нагрузки на Node и числа «тяжёлых» запросов.

### Вариант A. Раздача части фото статикой через Nginx (рекомендуемый первый шаг)

**Идея:** картинки, для которых путь совпадает с реальным файлом на диске, отдавать напрямую с диска через Nginx (без Node). Запросы с fallback (ручки по коду, двери по префиксу) по-прежнему идут в Node.

**Что нужно:**

1. **На ВМ** сделать так, чтобы Nginx имел доступ к тем же файлам, что и приложение (например, симлинк или alias на `~/domeo-app/public/uploads` или копия только `final-filled/doors` и т.п.).
2. **В Nginx** для `location /uploads/`:
   - сначала попытка отдать файл с диска (alias/root + try_files);
   - если файла нет — proxy_pass на бэкенд (Next), чтобы сработал rewrite → `/api/uploads/...` и текущий API с fallback.
3. **В Next** либо убрать rewrite `/uploads/` → `/api/uploads/` для запросов, которые уже обработал Nginx (не нужно — Nginx не отправит их в Next), либо оставить rewrite: тогда запросы, не найденные Nginx (try_files = 404), нужно проксировать в бэкенд как `/api/uploads/...` (например, через error_page 404 = @backend_uploads).
4. Итог: для «прямых» путей (большинство дверей по точному имени) ответ даёт Nginx с диска (быстро, без Node); только запросы без файла попадают в Node для fallback.

**Плюсы:** сильное снижение нагрузки на Node и ускорение загрузки для большинства картинок. **Минусы:** нужна настройка Nginx и единого каталога файлов на ВМ.

---

### Вариант B. In-memory кеш в API `/api/uploads/[...path]`

**Идея:** не менять схему запросов, но в обработчике кешировать в памяти результат успешного чтения файла (буфер или путь к файлу) по нормализованному ключу (URL path), с ограничением по размеру или количеству записей (LRU).

**Что даёт:** повторные запросы одного и того же URL (в т.ч. при перезаходе на страницу, скролле) не трогают диск и fallback — ответ быстрее. Первый запрос по-прежнему медленный; «не все грузятся» за счёт лимитов/таймаутов это не снимает, но снижает вероятность перегрузки при повторных запросах.

**Плюсы:** реализуется только в коде API, без Nginx. **Минусы:** рост потребления памяти; нужны ограничения (макс. размер кеша, TTL).

---

### Вариант C. Ослабить лимиты Nginx для /uploads/ и увеличить таймауты

**Идея:** для `location /uploads/` (и при необходимости для `/api/uploads/`) увеличить limit_req (или убрать), увеличить proxy_read_timeout и proxy_connect_timeout, чтобы реже получать 503 и обрывы по таймауту.

**Что даёт:** меньше «не загрузилось» из-за rate limit и таймаутов, но Node по-прежнему обрабатывает каждый запрос и остаётся узким местом по скорости.

**Плюсы:** только правка конфига Nginx. **Минусы:** не решает корневую причину медленной отдачи (всё через Node + диск).

---

### Вариант D. Уменьшить число и «вес» запросов на первом экране

**Идея:** не менять способ раздачи файлов, а уменьшить объём запросов и данных:

- Для списка моделей (сетка карточек) использовать **уменьшенные превью** (отдельные файлы-миниатюры или генерация на лету), если появятся — меньше байт и быстрее первая отрисовка.
- Сохранять **loading="lazy"** и при необходимости ограничивать число одновременно запрашиваемых фото (например, приоритет видимым в viewport, остальные подгружать с небольшой задержкой или батчами), чтобы не создавать пики по 50+ запросов в секунду.

**Плюсы:** меньше конкуренции за соединения и Node. **Минусы:** требует либо подготовки превью/отдельного API, либо правок фронта (приоритизация/батчи) и возможных доработок бэкенда.

---

### Вариант E. CDN или внешнее хранилище для статики

**Идея:** вынести файлы из `public/uploads` в объектное хранилище (S3, Yandex Object Storage и т.п.) или CDN; в API complete-data и hardware отдавать уже полные URL на эти ресурсы; фронт грузит картинки с другого origin, без нагрузки на Node и с кешированием CDN.

**Плюсы:** максимальное ускорение и стабильность загрузки. **Минусы:** смена схемы хранения и URL, миграция файлов, возможная смена процесса загрузки/импорта фото.

---

## 4. Рекомендуемый порядок внедрения

1. **Сначала A (Nginx static для /uploads/)** — максимальный эффект при ограниченных изменениях (конфиг Nginx + структура каталогов на ВМ). Оставить fallback в Node для путей без точного файла.
2. **При необходимости B (кеш в API)** — дополнительное ускорение повторных запросов и снижение нагрузки на диск без смены архитектуры.
3. **C (лимиты/таймауты)** — быстрая подстраховка, чтобы реже терять картинки из-за 503 и таймаутов, можно сделать параллельно с A.
4. **D и E** — по мере требований к скорости и масштабу (превью, CDN).

После выбора вариантов можно переходить к конкретным правкам в коде и конфигах (в следующем шаге).
