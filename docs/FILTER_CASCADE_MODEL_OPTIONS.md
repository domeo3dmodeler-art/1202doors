# Каскад фильтрации model-options (шаг за шагом)

## Роль кода и названия модели

- **Код модели Domeo (Web)** — только **фильтр/группировка**: объединяет несколько разных **Название модели** (у каждой свой набор опций и ограничений). В коде и в API не несёт опций сам по себе.
- **Название модели** — каноническое поле «под капотом»: у каждого товара своё значение (например «ДПГ Флекс Эмаль Порта ПТА-50 B», «Дверь Гладкое ДГ»). К нему привязаны все опции и ограничения (наполнение, покрытие, кромка в базе, размеры и т.д.). Фильтрация опций идёт через отфильтрованный набор товаров, т.е. по фактическим **Название модели** в этом наборе.
- **Domeo_Название модели для Web** — устаревший параметр, **сейчас не используется**; ориентироваться на **Название модели**.
- **В интерфейсе** пользователю показывается только код/название из каталога (например «Base 1»). **Название модели** в UI не выводится; оно нужно для правильной фильтрации опций и подставляется в **Excel при экспорте заказа**.

**Откуда берётся «Название модели» в экспорте:** при расчёте цены (POST /api/price/doors) выбирается товар по текущим фильтрам (код, стиль, размер, наполнение, покрытие, цвет и т.д.); у этого товара из БД берётся поле **Название модели** и возвращается в ответе как `model_name`. При добавлении в корзину это значение сохраняется в позиции (`model_name`). Оно попадает в заказ (cart_data) и при экспорте в Excel подставляется в колонку «Название модели». Так в файле оказывается именно та подмодель, которая соответствует выбранной конфигурации, а не первая попавшаяся с тем же кодом.

## Ключи в properties_data (канонические)

- **Код модели Domeo (Web)** — код модели (фильтр, группирует несколько Название модели)
- **Название модели** — фабричное название подмодели; опции и ограничения привязаны к нему; используется в фильтрации и в экспорте в Excel
- **Domeo_Стиль Web** — стиль (Современная, Классика и т.д.)
- **Ширина/мм** — ширина в мм (число)
- **Высота/мм** — высота в мм (число)
- **Тип покрытия** — ПЭТ, ПВХ, Эмаль, Шпон
- **Domeo_Опции_Название_наполнения** — наполнение (Сильвер, Голд и т.д.)
- **Domeo_Опции_Реверс_доступен** — «да»/«нет»

## Порядок фильтров в API GET /api/catalog/doors/model-options

1. **Код модели + стиль** — `getProductsByModelAndStyle(products, model, style)`  
   Оставляются товары, у которых `Код модели Domeo (Web) === model` и `Domeo_Стиль Web === style`.

2. **Реверс** (если в запросе `reversible=true`)  
   Оставляются только товары с `Domeo_Опции_Реверс_доступен` содержащим «да».

3. **Наполнение** (если в запросе передан `filling`)  
   Оставляются товары с `Domeo_Опции_Название_наполнения === filling`.

4. **Ширина** (если передан `width`)  
   Оставляются товары с `Ширина/мм === width` (сравнение как число).

5. **Высота** (если передан `height`)  
   Используется `heightForFilter(height)` (например 2350 → 2000), затем оставляются товары с `Высота/мм === height`.

6. **Тип покрытия** (если передан `finish`)  
   Оставляются товары с `Тип покрытия === finish`.

7. **Цвет** (если передан `color`)  
   Оставляются товары по `Цвет/Отделка`.

**Важно:** списки для селекторов (fillings, widths, heights, **finishes**, colorsByFinish, revers_available, mirror_available, threshold_available) собираются **после фильтра по размеру, но до фильтра по покрытию и цвету**. Иначе при уже выбранном типе покрытия (например ПВХ) в ответе было бы только оно — и в интерфейсе отображалось бы одно покрытие вместо всех доступных для выбранного размера. Фильтр по покрытию/цвету применяется только для edges и filteredCount.

## Диагностика: на каком шаге «пропадают» покрытия

В запрос можно добавить **`debug=1`**:

```
GET /api/catalog/doors/model-options?model=DomeoDoors_Base_1&style=Современная&width=800&height=2100&debug=1
```

В ответе появится массив **`debugSteps`**: после каждого применённого фильтра — шаг, количество товаров и список типов покрытия (`Тип покрытия`) у этих товаров.

Пример:

```json
{
  "data": {
    "finishes": ["ПВХ"],
    "filteredCount": 7,
    "debugSteps": [
      { "step": "1. Код модели Domeo (Web) + Domeo_Стиль Web", "count": 50, "finishes": ["ПЭТ", "ПВХ", "Эмаль"] },
      { "step": "4. Ширина/мм", "count": 20, "finishes": ["ПЭТ", "ПВХ", "Эмаль"] },
      { "step": "5. Высота/мм", "count": 7, "finishes": ["ПВХ"] }
    ]
  }
}
```

Здесь видно, что после шага «5. Высота/мм» остаются только товары с ПВХ — значит, в БД для 800×2100 по этому коду и стилю заполнено поле **Высота/мм** только у товаров с ПВХ (или у ПЭТ/Эмаль значения отличаются/не заполнены).

Дальше нужно смотреть реальные записи в БД: у товаров с Код модели Domeo (Web) = DomeoDoors_Base_1, Domeo_Стиль Web = Современная, Тип покрытия ПЭТ/Эмаль — какие именно значения в **Ширина/мм** и **Высота/мм**.

## Откуда фронт передаёт параметры

На странице конфигуратора дверей (`app/doors/page.tsx`) в `modelOptionsParams` уходят:

- `reversible` — чекбокс «Реверс»
- `selectedFilling` — выбранное наполнение (если есть блок наполнения)
- `width`, `height` — выбранные размеры (например 800, 2100)

Они попадают в `useModelOptions(selectedModelId, selectedStyle, modelOptionsParams)`, который дергает `/api/catalog/doors/model-options` с query-параметрами `model`, `style`, `reversible`, `filling`, `width`, `height`, `finish`, `color`.

Если после выбора «Современная» и «Base 1» в списке покрытий только ПВХ — вызовите тот же URL с теми же `model`, `style`, `width`, `height`, что и фронт, и с `debug=1`, и по `debugSteps` определите, на каком шаге исчезают ПЭТ и Эмаль.

## Почему доступна кромка для данного сочетания

Блок «АЛЮМИНИЕВАЯ КРОМКА» и конкретные варианты (матовый хром, матовое золото и т.д.) зависят от двух вещей.

### 1. Каталог кромок по модели (complete-data)

- **edge_in_base** — у модели считается `true`, если у хотя бы одного товара этой модели в БД поле `Domeo_Кромка_в_базе_включена === 'да'`. Тогда в интерфейсе нет варианта «Без кромки», показываются только цвета кромки (с наценками).
- **Список вариантов кромки** (названия и наценки) берётся из complete-data: либо `edge_options` (поля `Domeo_Кромка_базовая_цвет`, `Domeo_Кромка_Цвет_2/3/4` и наценки), либо собирается по всем товарам модели — уникальные значения свойства **Кромка** в `properties_data`.

То есть «кромка вообще есть у модели» и «какие цвета показывать в каталоге» определяются по данным модели (complete-data), а не по текущему выбору размера/покрытия.

### 2. Какие из этих кромок разрешены для текущего выбора (model-options)

- Страница конфигуратора запрашивает `GET /api/catalog/doors/model-options` с параметрами: `model`, `style`, `filling`, `width`, `height`, `finish`, `color`.
- В API после фильтров 1–5 (модель, стиль, наполнение, ширина, высота) и при необходимости 6–7 (тип покрытия, цвет) из оставшихся товаров собираются уникальные значения **Кромка** (пустые и «-» отбрасываются). Это массив **edges** в ответе.
- В интерфейсе блок «АЛЮМИНИЕВАЯ КРОМКА» строится так: из полного списка кромок модели (п.1) показываются только те, чьё название (`edge_color_name`) входит в **edges** из model-options.

**Итог (обновлено):** Код Base_1 объединяет **4 подмодели** (ДПГ Флекс Эмаль Порта ПТА-50 B, Дверь Гладкое ДГ, Дверь Гладкое эмаль ДГ, Дверное полотно BASE 1 ПГ иск.п.). Для каждой комбинации (модель + стиль + размер + наполнение + **покрытие**) model-options считает по **отфильтрованному** набору товаров:

- **edge_in_base** — есть ли у хотя бы одного товара в этом наборе `Domeo_Кромка_в_базе_включена = 'да'`.
- **edges** — уникальные значения **Кромка** только по этому набору (без подстановки списка с других покрытий).

Для **ПЭТ** после фильтра остаётся только подмодель «ДПГ Флекс Эмаль Порта ПТА-50 B», у которой в БД кромки в базе нет (`Domeo_Кромка_в_базе_включена = 'Нет'`, **Кромка** пусто). Поэтому при выборе ПЭТ API возвращает `edge_in_base: false` и `edges: []` — в интерфейсе показывается только «Без кромки», без вариантов матовый хром и т.д.

---

## Как модель попадает в корзину, заказ и экспорт (в т.ч. «не мерные»)

### Что показывается в UI

- В интерфейсе отображаются **коды моделей** (например «Base 1»), сгруппированные по **Код модели Domeo (Web)** в `complete-data`. Один код объединяет все товары с разными **Название модели** (подмодели). Конкретное «Название модели» в UI **не показывается** — пользователь выбирает только код, стиль, размер, наполнение, покрытие, цвет и т.д.

### Цепочка: расчёт цены → корзина → заказ → Excel

1. **Расчёт цены (POST /api/price/doors)**  
   Движок (`lib/price/doors-price-engine.ts`) фильтрует товары по коду, стилю, размеру, наполнению, покрытию, цвету. Среди **всех подходящих** записей выбирается **один** товар по правилу **pickMaxPriceProduct** — берётся товар с **максимальной РРЦ**. У этого товара из БД берётся поле **Название модели** и возвращается в ответе как `model_name`.

2. **Добавление в корзину**  
   На фронте в позицию сохраняются `model` (код, например `DomeoDoors_Base_1`) и `model_name` из ответа price API. Остальные поля (finish, color, width, height, edge, reversible и т.д.) тоже пишутся из текущего выбора.

3. **Заказ**  
   В `cart_data` попадает тот же объект позиции: `model`, `model_name`, размеры, покрытие, цвет и т.д.

4. **Экспорт в Excel**  
   - Если для позиции находится совпадение в БД (`getMatchingProducts` по model, model_name, finish, color, width, height) — колонка «Название модели» заполняется из `Product.properties_data['Название модели']` найденного товара (или нескольких, если несколько поставщиков).  
   - Если совпадения нет — используется **fallback**: сначала `item.model_name` из корзины, затем `getModelNameByCode(item.model)`, который возвращает **Название модели** у **первого** найденного в БД товара с этим кодом (без фильтра по размеру/покрытию), затем преобразование кода в читаемый вид.

### Почему в экспорте оказываются «не мерные» модели

Сейчас в коде **нигде не разделяются** «мерные» и «не мерные» подмодели:

- При расчёте цены среди всех подходящих по коду и конфигурации товаров выбирается один по **максимальной РРЦ**. Если у этого товара **Название модели** — «не мерная» подмодель (например «Дверное полотно BASE 1 ПГ иск.п.»), то именно она попадает в `model_name` и далее в корзину, заказ и в колонку «Название модели» в Excel.
- В fallback-сценарии (нет совпадения в БД по полной конфигурации) `getModelNameByCode(model)` возвращает название **первого** товара с данным кодом — им тоже может оказаться «не мерная» подмодель.

То есть в экспорте «не мерные» модели появляются не из-за отдельной передачи «скрытых» моделей, а из-за того, что:
- в корзину и заказ попадает `model_name` от того товара, который был выбран при расчёте цены (по правилу «макс. РРЦ»);
- при отсутствии совпадения в экспорте подставляется название от первого товара с этим кодом.

### Что можно сделать, чтобы в экспорт не попадали «не мерные»

Чтобы в корзину/заказ/экспорт шли только «мерные» подмодели, нужно явно ввести различие в логике:

1. **В каталоге/БД** — завести признак «мерная» подмодель (например поле в `properties_data`: «Мерная» = «да»/«нет», или список/паттерны «Название модели», которые считаются мерными).
2. **В движке цен** — среди отфильтрованных по коду и конфигурации товаров **сначала** отфильтровать только товары с признаком «мерная» (или исключить «не мерные»), и уже среди них вызывать `pickMaxPriceProduct`. Если мерных нет — можно оставить текущее поведение или явно падать/подставлять заглушку.
3. **В product-match** — при fallback `getModelNameByCode` / `getModelMetadataByCode` при необходимости возвращать только «мерный» товар (например первый с признаком «мерная»), чтобы в Excel при отсутствии точного совпадения тоже не подставлялось «не мерное» название.

После введения такого признака в данных и правок в price engine и (при необходимости) в product-match цепочка «модель → корзина → заказ → экспорт» будет передавать только выбранные (мерные) подмодели.
