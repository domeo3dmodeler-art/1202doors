# Фильтрация покрытий и цветов дверей: от БД до UI

Как устроена строгая фильтрация и откуда берутся варианты (покрытие + цвет) для отображения на UI.

---

## 1. Источник данных в БД

**Таблица:** `Product` (каталог дверей).  
**Поля:** `properties_data` (JSON). В нём используются ключи:

- **Код модели Domeo (Web)** — код модели (например `DomeoDoors_Base_1`).
- **Domeo_Стиль Web** — стиль (Классика, Неоклассика, Современная и т.д.).
- **Тип покрытия** — ПВХ, ПЭТ, Эмаль, Шпон.
- **Цвет/Отделка** — название цвета (Белый, Белоснежный и т.д.).

Один товар = одна комбинация (модель, стиль, размер, наполнение, тип покрытия, цвет, …). Список вариантов покрытий и цветов по модели формируется из **набора таких товаров**.

**Фото цветов** хранятся в `property_photos`: свойство `Domeo_Модель_Цвет`, значение `propertyValue` в формате `Код|Тип покрытия|Цвет` (сравнение через trim + toLowerCase). Путь к файлу — в `photoPath`.

---

## 2. API complete-data

**Маршрут:** `GET /api/catalog/doors/complete-data`

**Логика:**

1. Читаются все активные товары категории дверей из БД.
2. Группировка по **Код модели Domeo (Web)**. При `?style=...` отбрасываются товары с другим стилем.
3. **modelEntries:** в ответ попадают только пары (modelKey, style), у которых есть **хотя бы один товар**. Без фильтра по стилю для каждого modelKey по товарам собираются уникальные стили и для каждой пары (modelKey, style) создаётся запись только если есть товары с этой парой.
4. Для каждой такой записи **покрытия (coatings)** строятся только из товаров этой пары:
   - по каждому товару берутся `Тип покрытия` и `Цвет/Отделка`;
   - уникальные пары дают элементы `coatings`: `id = "Тип покрытия_Цвет/Отделка"`, `coating_type`, `color_name`;
   - `photo_path` подставляется из `property_photos` по ключу `modelKey|Тип покрытия|Цвет` (PropertyPhoto, свойство `Domeo_Модель_Цвет`).

**Итог:** В ответе у каждой модели есть массивы `coatings`, `options.finishes`, `colorsByFinish`. Это **полный** список покрытий и цветов по товарам данной (modelKey, style). Источник — только Product.properties_data (Тип покрытия, Цвет/Отделка).

---

## 3. API model-options (каскад)

**Маршрут:** `GET /api/catalog/doors/model-options?model=...&style=...&reversible=...&filling=...&width=...&height=...&finish=...&color=...`

**Логика:**

1. Читаются те же товары (категория дверей).
2. Последовательно применяются фильтры:
   - модель и стиль (`Код модели Domeo (Web)`, `Domeo_Стиль Web`);
   - при наличии — реверс, наполнение (`Domeo_Опции_Название_наполнения`);
   - при наличии — ширина/высота (`Ширина/мм`, `Высота/мм`);
   - при наличии — тип покрытия (`Тип покрытия`);
   - при наличии — цвет (`Цвет/Отделка`).
3. **Важно:** списки для селекторов (покрытия, цвета по покрытию) строятся **до** фильтра по покрытию и цвету — из набора товаров после фильтра по модели, стилю, реверсу, наполнению и размерам (стр. 111–114 в route):
   - `optionsAfterSize = collectOptions(filtered)` — после фильтра по размеру (и до фильтра по finish/color);
   - в ответ уходят `finishes`, `colorsByFinish` из `optionsAfterSize`.
4. В `collectOptions` по отфильтрованному списку товаров собираются:
   - из каждого товара: `Тип покрытия` → в `finishes`, и `Цвет/Отделка` (getCanonicalColor = `Цвет/Отделка`) → в `colorsByFinish[Тип покрытия]`.

**Итог:** `colorsByFinish` — это «какие цвета реально есть у товаров при текущих выбранных модели, стиле, реверсе, наполнении и размерах». Фильтр по покрытию и цвету дальше только сужает набор для расчёта цены и кромки, но не меняет списки для селекторов.

---

## 4. UI: откуда список и как фильтруется

**Источники:**

- **coatings, finishes, colorsByFinish** по выбранной модели — из **complete-data** через `useModelDetails(selectedModelId, rawModels, selectedStyle)`: берётся запись с подходящими modelKey и style, из неё `coatings`, `options.finishes`, `colorsByFinish`.
- **modelOptionsData** (в т.ч. `finishes`, `colorsByFinish`) — из **model-options** через `useModelOptions(selectedModelId, selectedStyle, modelOptionsParams)`. В `modelOptionsParams` передаются текущие: reversible, filling, width, height, finish, color.

**Отображение типов покрытия:**

- Список кнопок (ПВХ, ПЭТ, Эмаль, …) строится из `cascadeFinishes`: если есть `modelOptionsData.finishes` — берётся он, иначе `finishes` из complete-data.

**Отображение цветов (варианты по выбранному покрытию):**

- `filteredCoatings`:
  1. Берутся только элементы `coatings` (complete-data) с `coating_type === selectedFinish`.
  2. Если для выбранной модели есть `modelOptionsData.colorsByFinish[selectedFinish]` и он непустой, то оставляются только те покрытия, у которых `color_name` (после trim) входит в этот список.
- В блоке «Цвет» (ПВХ/ПЭТ/Эмаль) рендерятся `monochromeColors`, которые строятся из `filteredCoatings` (id, name = color_name, photo_path).

То есть на UI показываются **только те варианты цветов, которые есть и в complete-data (по модели+стилю), и в каскаде (по модели+стилю+реверс+наполнение+размеры)**. Фильтрация строгая: без подмешивания «полного списка», если каскад что-то отфильтровал.

---

## 5. Почему варианты цветов могут не отображаться

Возможные причины при **строгой** фильтрации:

1. **В complete-data нет покрытий для этой (modelKey, style)**  
   Тогда `coatings` пустой. Так бывает, если:
   - для этой пары нет ни одного товара в БД, или
   - у всех товаров этой пары не заполнены `Тип покрытия` или `Цвет/Отделка` в `properties_data`.  
   **Что проверить:** в БД у товаров с данным кодом и стилем наличие и заполненность полей `Тип покрытия` и `Цвет/Отделка`.

2. **Каскад возвращает пустой colorsByFinish для выбранного покрытия**  
   Тогда после фильтра по `allowedColors` список обнуляется. Так бывает, если:
   - после фильтра по модели, стилю, реверсу, наполнению и **размерам** не остаётся ни одного товара с таким типом покрытия;
   - или у оставшихся товаров нет значения `Цвет/Отделка` для этого типа покрытия.  
   **Что проверить:** запрос к `model-options` с теми же model, style, width, height, filling, reversible — смотреть `colorsByFinish` и `filteredCount`. При `filteredCount === 0` или пустом `colorsByFinish[selectedFinish]` цвета на UI не покажутся — это ожидаемо при такой комбинации фильтров.

3. **Несовпадение имён цветов**  
   complete-data и model-options оба берут цвет из `Цвет/Отделка`, но если в одном месте строка с лишними пробелами или в разном регистре, а сравнение на UI не нормализует — возможны лишние отсечения. На UI сейчас используется сравнение с trim для обеих сторон (`allowed.has(String(c.color_name ?? '').trim())`), регистр в `allowed` не меняется (в API в collectOptions цвет добавляется как есть из БД). Если в БД в разных товарах одно и то же значение записано по-разному (например «Белый» и «Белый »), то в complete-data и в colorsByFinish могут попасть разные варианты написания и пересечение даст пустоту.  
   **Что проверить:** единообразие значений `Цвет/Отделка` в БД и при необходимости нормализация (trim, единый регистр) при формировании `colorsByFinish` и при сравнении на UI.

4. **Фото не отображаются при наличии вариантов**  
   Список цветов есть, но превью пустые — тогда смотреть цепочку для `photo_path`: наличие записей в `property_photos` с `Domeo_Модель_Цвет` и `propertyValue` в формате `код|Тип покрытия|Цвет` (см. DOOR_PHOTOS_CHAIN.md и DOOR_CONFIGURATOR_DATA_RULES.md).

---

## 6. Краткая схема

```
БД: Product.properties_data [Код модели, Domeo_Стиль Web, Тип покрытия, Цвет/Отделка]
         │
         ├──► complete-data: по (modelKey, style) собирает coatings из товаров этой пары
         │    → в UI: useModelDetails → coatings, finishes, colorsByFinish
         │
         └──► model-options: фильтр по model, style, reversible, filling, width, height
              collectOptions(после размера, до finish/color) → finishes, colorsByFinish
              → в UI: useModelOptions → modelOptionsData.finishes, modelOptionsData.colorsByFinish

UI: Типы покрытия = modelOptionsData.finishes || finishes из модели
    Цвета по выбранному покрытию = coatings (модель) по selectedFinish,
    отфильтрованные по modelOptionsData.colorsByFinish[selectedFinish] (строгое пересечение).
```

Чтобы варианты цветов дверей отображались, должны выполняться:

- в БД есть товары с данной моделью и стилем и заполненными Тип покрытия и Цвет/Отделка;
- после фильтра каскада по размерам/наполнению/реверсу остаётся хотя бы один такой товар с выбранным типом покрытия;
- значения цветов в complete-data и в model-options совпадают (после trim), и на UI используется строгое пересечение без «подмешивания» полного списка.
