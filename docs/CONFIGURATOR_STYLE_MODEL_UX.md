# Калькулятор дверей: смена стиля и модели — логика и UX

## Что происходит сейчас

### При нажатии на другой **стиль**

1. **Модель**  
   Список моделей фильтруется по новому стилю (`filteredModels`).  
   Если текущая выбранная модель **не входит** в новый список → автоматически выбирается **первая модель** нового стиля.  
   Если входит → модель не меняется.

2. **Остальные опции** (покрытие, цвет, размеры, ручка, ограничитель и т.д.)  
   **Ничего не сбрасывается.** Остаётся то, что было выбрано для предыдущего стиля/модели.

3. **Цена**  
   Сбрасывается при смене модели (в т.ч. когда модель сменилась из‑за смены стиля).

### При выборе другой **модели** (в том же стиле)

1. **Тип покрытия (ПЭТ/ПВХ/Эмаль/Шпон)**  
   Подстраивается под новую модель: выставляется **первый тип из списка** для этой модели, либо сохраняется текущий, если он есть в новом списке.

2. **Покрытие и цвет**  
   Явного сброса нет. Сбрасываются только в эффекте «если тип покрытия не совпадает с выбранным покрытием».  
   Если у новой модели другой набор цветов, старый выбор может оказаться **невалидным** (цвет из другой модели).

3. **Цвет стекла**  
   Сбрасывается: `setSelectedGlassColor(null)`.

4. **Кромка**  
   Если у модели «кромка в базе» — выбирается первая кромка из списка; иначе проверяется, что выбранная кромка есть в списке, при отсутствии — сброс.

5. **Реверс**  
   Если у новой модели реверс недоступен — галочка реверса снимается.

6. **Цена**  
   Сбрасывается при смене модели.

7. **Ручка, ограничитель, наличники, зеркало, порог, размеры**  
   Не сбрасываются.

---

## Проблемы текущего UX

1. **Смена стиля**  
   Покрытие, цвет, размеры, ручка и т.д. остаются от старой конфигурации. Пользователь может не понять, что часть опций уже «от другой двери» и не факт, что они применимы к новой.

2. **Смена модели**  
   Покрытие/цвет могут остаться от старой модели и не входить в допустимые для новой → невалидное состояние и путаница.

3. **Нет явного «каскадного» сброса**  
   Ожидание пользователя: «выбрал другой стиль/модель → всё, что от них зависит, пересобралось заново». Сейчас это выполняется только частично.

---

## Рекомендуемая логика UX/UI

### Принцип: каскадная зависимость

- **Стиль** → определяет список моделей.
- **Модель** → определяет: типы покрытия, цвета, кромки, реверс, размеры (и т.д., если есть ограничения).
- **Тип покрытия** → определяет список цветов/покрытий.
- Остальное (ручка, ограничитель, наличники, зеркало, порог) можно оставлять, если они не привязаны к модели.

### При смене **стиля**

- **Модель**: оставить текущую, если она есть в новом списке; иначе — первую модель нового стиля (как сейчас).
- **Сбросить к «первому валидному» для новой конфигурации**:
  - тип покрытия (первый из списка для выбранной модели);
  - покрытие и цвет (первый допустимый для этого типа);
  - кромка (по правилу «в базе» / «без кромки»);
  - реверс (если модель не поддерживает — снять).
- **Опционально сбрасывать** (по желанию продукта):
  - ручка, ограничитель, наличники, зеркало, порог — чтобы конфигурация была «чистой» под новую дверь.
- **Размеры** можно не сбрасывать (800×2000 и т.д. часто общие).
- **Цена** всегда сбрасывать при смене стиля/модели (как сейчас).

### При смене **модели**

- **Тип покрытия**: первый из списка для новой модели или текущий, если он в списке (как сейчас).
- **Покрытие и цвет**: если текущие **не входят** в допустимые для новой модели → выставить **первый допустимый** (или «не выбрано» и подсветить блок выбора цвета).
- Кромка, реверс, цвет стекла — уже ведут себя разумно; при необходимости добавить явную проверку «выбранное входит в список для модели».
- Ручка, ограничитель и т.д. — по продуктовому решению: оставлять или сбрасывать.
- Цена — сбрасывать.

### Подсказки в UI

- При смене стиля/модели можно один раз показать тост/подсказку: «Выбран новый стиль/модель. Проверьте покрытие и цвет».
- Если после смены модели текущее покрытие/цвет невалидны — подсветить блок «Покрытие и цвет» и предложить выбрать заново (или автоматически подставить первый валидный вариант).

---

## Что стоит доработать в коде

1. **При смене модели**  
   Добавить эффект: если `selectedCoatingId` не входит в `filteredCoatings` для текущей модели → сбросить покрытие/цвет и выставить первый элемент из `filteredCoatings` (или `null` и показывать «Выберите цвет»).

2. **При смене стиля**  
   Либо явно вызывать тот же каскад, что и при смене модели (после того как обновился `selectedModelId`), либо ввести общую функцию «синхронизировать опции с текущей моделью» и вызывать её при смене стиля и при смене модели.

3. **Опционально**  
   При смене стиля/модели сбрасывать ручку, ограничитель, наличники и т.д. в нейтральное состояние, если продукт решит, что «новая дверь = чистая конфигурация».

После этих шагов поведение калькулятора будет предсказуемым и соответствовать ожиданию «выбрал другой стиль/модель — всё зависимое подстроилось под новую дверь».
